<html><head><link rel="stylesheet" type="text/css" href="../Semantic/semantic.min.css"><script src="../Semantic/jquery.min.js" type="text/javascript"></script><script src="../Semantic/semantic.min.js" type="text/javascript"></script><title>Vertex Cover</title></head><body><div class="ui main container"><div class="ui center aligned grid"><div class="row"><h1 class="ui header">HDU6150. Vertex Cover</h1></div><div class="row" style="margin-top: -15px"><span class="ui label">内存限制：2000/1000 MS (Java/Others)</span> <span class="ui label">时间限制：256000/256000 K (Java/Others)</span></div></div></br><div class="row"><div class="column"><h4 class="ui top attached block header">题目描述</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">As we know, $minimum vertex cover$ is a classical NP-complete problem. There will not be polynomial time algorithm for it unless $P = NP$.<br><br>You can see the definition of vertex cover in https://en.wikipedia.org/wiki/Vertex_cover.<br><br>Today, little M designs an &quot;approximate&quot; algorithm for vertex cover. It is a greedy algorithm. The main idea of her algorithm is that always choosing the maximum degree vertex into the solution set. The pseudo code of her algorithm is as follows:<br><br>We assume that the labels of the vertices are from 1 to n.<br><pre><br>for (int i = 1; i &lt;= n; ++i) {<br>&nbsp;&nbsp;use[i] = false;<br>    deg[i] = degree of the vertex i;<br>}<br>int ans = 0;<br>while (true) {<br>&nbsp;&nbsp;int mx = -1, u;<br>    for (int i = 1; i &lt;= n; ++i) {<br>    &nbsp;&nbsp;if (use[i])<br>        &nbsp;&nbsp;continue;<br>        if (deg[i] &gt;= mx) {<br>        &nbsp;&nbsp;mx = deg[i];<br>            u = i;<br>        }<br>    }<br>    if (mx &lt;= 0)<br>    &nbsp;&nbsp;break;<br>    ++ans;<br>    use[u] = true;<br>    for (each vertex v adjacent to u)<br>    &nbsp;&nbsp;--deg[v];<br>}<br>return ans;<br></pre><br><br>As a theory computer scientist, you immediately find that it is a bad algorithm. To show her that this algorithm dose not have a constant approximate factor, you need to construct an instance of vertex cover such that the solution get by this algorithm is much worse than the optimal solution.<br><br>Formally, your program need to output a simple undirected graph of at most $500$ vertices. Moreover, you need to output a vertex cover solution of your graph. Your program will get Accept if and only if the solution size get by the above algorithm is at least three times as much as yours. <br></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">输入格式</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">There is no input.<br></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">输出格式</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">First, output two integer $n$ and $m$ in a line, separated by a space, means the number of the vertices and the number of the edges in your graph.<br>In the next $m$ lines, you should output two integers $u$ and $v$ for each line, separated by a space, which denotes an edge of your graph. It must be satisfied that $1 \leq u,v \leq n$ and your graph is a simple undirected graph.<br>In the next line, output an integer $k(1 \leq k \leq n)$, means the size of your vertex cover solution.<br>Then output $k$ lines, each line contains an integer $u(1 \leq u \leq n)$ which denotes the label of a vertex in your solution. It must be satisfied that your solution is a vertex cover of your graph.<br></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">样例</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;"><h4>样例输入</h4><div class="ui existing segment"><pre style="margin-top:0; margin-bottom:0;"><code class="lang-plain"></code></pre></div><h4>样例输出</h4><div class="ui existing segment"><pre style="margin-top:0; margin-bottom:0;"><code class="lang-plain">4 4
1 2
2 3
3 4
4 1
2
1
3

<div style='font-family:Times New Roman;font-size:14px;background-color:F4FBFF;border:#B7CBFF 1px dashed;padding:6px'><div style='font-family:Arial;font-weight:bold;color:#7CA9ED;border-bottom:#B7CBFF 1px dashed'><i>Hint</i></div>
The sample output is just to exemplify the output format.
</div><i style='font-size:1px'> </i></div></code></pre></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">数据范围与提示</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;"> <a href="/search.php?field=problem&key=2017%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%B3%CC%D0%F2%C9%E8%BC%C6%BE%BA%C8%FC+-+%CD%F8%C2%E7%D1%A1%B0%CE%C8%FC&source=1&searchmode=source"> 2017中国大学生程序设计竞赛 - 网络选拔赛 </a> </div></div></div></div></div></div><div class="ui vertical footer segment"><div class="ui center aligned container"><span style="color: #999;">OI-offline-problem-reader Powered by <a href="http://www.sycstudio.com">SYCstudio</a>.</span></div></div></div></body></html>