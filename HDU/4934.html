<html><head><link rel="stylesheet" type="text/css" href="../Semantic/semantic.min.css"><script src="../Semantic/jquery.min.js" type="text/javascript"></script><script src="../Semantic/semantic.min.js" type="text/javascript"></script><title>Protocol Buffers</title></head><body><div class="ui main container"><div class="ui center aligned grid"><div class="row"><h1 class="ui header">HDU4934. Protocol Buffers</h1></div><div class="row" style="margin-top: -15px"><span class="ui label">内存限制：2000/1000 MS (Java/Others)</span> <span class="ui label">时间限制：65536/65536 K (Java/Others)</span></div></div></br><div class="row"><div class="column"><h4 class="ui top attached block header">题目描述</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">Protocol Buffers are a way of encoding structured data in an efficient yet extensible format. Google uses Protocol Buffers for almost all of its internal RPC protocols and file formats. In this problem, you will use a simplified version of protocol buffers.<br><br><b>Message definition:</b><br>In protocol buffers, we defining a message in a very simple way:<br>    message Gao {<br>      required int32 a = 1;<br>      required int32 b = 2;<br>      required string str = 3;<br>      repeated int32 arr = 4;<br>      optional int32 optionalField = 5;<br>    }<br>The Gao message definition specifies five fields (name/value pairs), one for each piece of data that you want to include in this type of message. In this problem, there are at most 15 fields in one message definition.<br><br><b>Field definition:</b><br>Foremost, we need specifying field rules in one of the following:<br>  1. required: message must have exactly one of this field.<br>  2. optional: message can have zero or one of this field (but not more than one).<br>  3. repeated: this field can be repeated any number of times (including zero) in message. The order of the repeated values will be preserved.<br>Follow by the field rules, we definiting field by type and name. we support int32 and string type in this problem. Each field has assigned a unique numbered tag at the end. These tags are used to identify your fields in the message binary format. The smallest tag number is 1, and the largest is 15. Field name is consist of letters([a-zA-Z]) and do not exceed 15 characters.<br><br><b>Base 128 Varints:</b><br>To understand your simple protocol buffer encoding, you first need to understand varints. Varints are a method of serializing integers using one or more bytes. Smaller numbers take a smaller number of bytes. Each byte in a varint, except the last byte, has the most significant bit (msb) set –– this indicates that there are further bytes to come. The lower 7 bits of each byte are used to store the two's complement representation of the number in groups of 7 bits, least significant group first.<br>So, for example, here is the number 1 –– it's a single byte, so the msb is not set:<br>    0000 0001<br>And here is 300 – this is a bit more complicated:<br>    1010 1100 0000 0010<br>How do you figure out that this is 300? First you drop the msb from each byte, as this is just there to tell us whether we've reached the end of the number (as you can see, it's set in the first byte as there is more than one byte in the varint):<br>    1010 1100 0000 0010<br>    → 010 1100  000 0010<br>You reverse the two groups of 7 bits because, as you remember, varints store numbers with the least significant group first. Then you concatenate them to get your final value:<br>    000 0010  010 1100<br>    →  000 0010 ++ 010 1100<br>    →  100101100<br>    →  256 + 32 + 8 + 4 = 300<br>(++ means byte concatenation)<br>It's more complex to consider signed number, due to simplify this problem, we only need considered unsigned integers in range [0, 10^9].<br><br><b>Message structure:</b><br>As you know, a protocol buffer message is a series of key-value pairs. The binary version of a message just uses the field's tag number as the key –– the name and declared type for each field can only be determined on the decoding end by referencing the message type's definition. The &quot;key&quot; for each pair in a wire-format message is actually two values – the field tag number from your message definition, plus a wire type that provides just enough information to find the length of the following value.<br>The available wire types are as follows:<br>    Type    Meaning                 Used for<br>    0       Varint                  int32<br>    2       Length-delimited        string,repeated fields<br>Each key in the streamed message is a varint with the value (field_tag_number &lt;&lt; 3) | wire_type –– in other words, the last three bits of the number store the wire type. For example, key of field a in message Gao is encoded as 0000 1000(08), and for field str is 0001 1010(1A). Field a seted as 150 will be encoded as 08 96 01 (Key is 08 and 150 encoded as 96 01). Concatenate all encoded fields we can get the encoded message.<br><br><b>Optional Elements:</b><br>If any of fields are optional, the encoded message may not have a key-value pair with that field, in this situation, just set the value of this field as null.<br><br><b>String and Repeated Elements:</b><br>In this situation, we need specifiy payload size (varint type) first after key, and followed by the elements. (We can regard string type as a array)<br>For example:<br>    message Test3 {<br>      required string b = 2;<br>      repeated int32 c = 3;<br>    }<br>Assume one message have the value &quot;testing&quot; for the field b and the values 3, 270, and 86942 for the repeated field c, then, the encoded form would be:<br>    12                    // tag (field number 2, wire type 2)<br>    07                    // payload size (7 bytes)<br>    74 65 73 74 69 6E 67  // ascii code of &quot;testing&quot;<br>    1A                    // tag (field number 3, wire type 2)<br>    06                    // payload size (6 bytes)<br>    03                    // first element (varint 3)<br>    8E 02                 // second element (varint 270)<br>    9E A7 05              // third element (varint 86942)<br>Notice, repeated string type in this problem is illegal.<br>If any of repetead fields not appeared in this message, this field can regard as empty array([]).<br>The length of arrays and strings will not exceed 50 and strings only consist of alphabet('a' - 'z' and 'A' - 'Z').<br><br><b>Problem:</b><br>Now give you a message definition, and serval encoded messages, you task is decode this messages. </div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">输入格式</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">The first line of input contains a number T, indicating the number of test cases. (T≤10).<br><br>For each case, there will be two integers n (n≤17) and m (m≤100).<br><br>The next n lines consist of message definition, you can assume that the length of message definition will not exceed 1500. A valid definition will only contains alphabet('a' - 'z' and 'A' - 'Z'), number('0' - '9'), whitespace(' ') and control tokens('=;{}').<br><br>And then followed by m querys, each line contain one encoded byte stream in hexadecimal notation, there is one whitespace after each byte. And for there are at most 1500 bytes each message. Notice there will be some empty byte stream in test data, see sample input for more details.<br><br>All the messages in this problem will not contains unknown tags and have a illegal structure.</div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">输出格式</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">For each case, output Case #i: first. (i is the number of the test case, from 1 to T).<br><br>Then for each query, output the values in each fields, with the same order in message definition.<br><br>If any of required fields not appeared in this message, please print Error! instead.<br><br>Output a blank line after each query.</div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">样例</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;"><h4>样例输入</h4><div class="ui existing segment"><pre style="margin-top:0; margin-bottom:0;"><code class="lang-plain">1
2 5
message Test1{required int32 a=1;required string b=2
;repeated int32 c=3;optional int32 optionalField=5;}
08 96 01 12 07 74 65 73 74 69 6e 67 1A 06 03 8E 02 9E A7 05 28 00
08 96 01 12 07 74 65 73 74 69 6e 67 1A 06 03 8E 02 9E A7 05

08 96 01 12 01 74
12 07 74 65 73 74 69 6e 67 1A 06 03 8E 02 9E A7 05</code></pre></div><h4>样例输出</h4><div class="ui existing segment"><pre style="margin-top:0; margin-bottom:0;"><code class="lang-plain">Case #1:
a = 150
b = "testing"
c = [3, 270, 86942]
optionalField = 0

a = 150
b = "testing"
c = [3, 270, 86942]
optionalField = null

Error!

a = 150
b = "t"
c = []
optionalField = null

Error!</div></code></pre></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">数据范围与提示</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;"> <a href="/search.php?field=problem&key=BestCoder+Round+%234&source=1&searchmode=source"> BestCoder Round #4 </a> </div></div></div></div></div></div><div class="ui vertical footer segment"><div class="ui center aligned container"><span style="color: #999;">OI-offline-problem-reader Powered by <a href="http://www.sycstudio.com">SYCstudio</a>.</span></div></div></div></body></html>