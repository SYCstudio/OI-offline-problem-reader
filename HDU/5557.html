<html><head><link rel="stylesheet" type="text/css" href="../Semantic/semantic.min.css"><script src="../Semantic/jquery.min.js" type="text/javascript"></script><script src="../Semantic/semantic.min.js" type="text/javascript"></script><title>Matching Compressed String</title></head><body><div class="ui main container"><div class="ui center aligned grid"><div class="row"><h1 class="ui header">HDU5557. Matching Compressed String</h1></div><div class="row" style="margin-top: -15px"><span class="ui label">内存限制：12000/6000 MS (Java/Others)</span> <span class="ui label">时间限制：65536/65536 K (Java/Others)</span></div></div></br><div class="row"><div class="column"><h4 class="ui top attached block header">题目描述</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">You are given a long string and looking for certain patterns in the string.<br>The string contains only lowercase letters $(a-z)$, and it is represented in a compressed format. Denoting $S_1, S_2, ...$ as compressed strings, another compressed string $S$ is defined recursively in one of the following ways:<br><br>&nbsp;&nbsp;$\cdot$ $S$ can be any string consisting of only lowercase letters $(a-z)$.<br>&nbsp;&nbsp;$\cdot$ $S$ can be generated by repeating another string for any times. Specifically, $S$ is represented as “<b>R(S1)</b>”, which means that the content of $S_1$ is repeated $R$ times.<br>&nbsp;&nbsp;$\cdot$ $S$ can also be the concatenation of other strings. Specifically, $S$ is represented as “$S_1,S_2...S_L$”, which means $S$ is the concatenation of $S_1, S_2, ..., S_L$.<br>&nbsp;&nbsp;$\cdot$An empty string (“”) is also a valid representation.<br><br>Formally, the Backus–Naur Form (BNF) specification of the syntax is<br><br>&lt;compressed&gt; ::= “” | &lt;lowercase-letter&gt; | &lt;compressed&gt; &lt;compressed&gt; | &lt;number&gt; “(” &lt;compressed&gt; “)”<br><br>For example, the string “baaabbaaab” can be compressed as “b3(a)2(b)3(a)b”. It can also be compressed as “2(b3(a)b)”.<br><br>On the other hand, you find deterministic finite automaton (DFA) as powerful way to describe the patterns you are looking for. A DFA contains a finite set of states $Q$ and a finite set of input symbols called the alphabet Σ. Initially, the DFA is positioned at the start state $q_0∈Q$. Given the transition function $δ(q,a)$ and an input symbol $a$, the DFA transit to state $δ(q,a)$ if its current state is $q$.<br><br>Let $w=a_1 a_2...a_n$ be a string over the alphabet Σ. According to the above definition, the DFA transits through the following sequence of states.<br>$$q_0,q_1=δ(q_0,a_1 ),q_2=δ(q_1,a_2 ),…,q_n=δ(q_(n-1),a_n )$$<br>The DFA also contains a set of accept states $F\subseteq Q$. If the last state $q_n$ is an accept state, we say that the DFA accepts the string $w$. The set of accepted strings is referred as the language that the DFA represents.<br><br>Now you are given a compressed string $S$ and a DFA $A$. You want to know if $A$ accepts the decompressed content of $S$. <br></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">输入格式</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">The first line of input contains a number T indicating the number of test cases ($T≤200$).<br><br>The first line of each test case contains a non-empty compressed string $S$, as described above. The length of $S$ is not greater than 10000, and $0≤R≤10^9$. It is guaranteed that the representation of $S$ is valid.<br><br>The description of the DFA follows.<br><br>The first line of the description contains three integers $N$, $M$, and $K$, indicating the number of states, the number of rules describing the transition function, and the number of accept states ($1≤K≤N≤1000,0≤M≤26N$). The states are numbered from 0 to $N-1$. The start state is always 0.<br><br>The second line contains $K$ integers representing the accept states. All these numbers are distinct.<br><br>Each of the next $M$ lines consists of two states $p$ and $q$, and an input symbol $a$, which means that the DFA transits from $p$ to $q$ when it receives the symbol $a$. The symbol $a$ is always a lowercase letter. It is guaranteed that, given $p$ and $a$, the next state $q$ is unique.<br></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">输出格式</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">For each test case, output a single line consisting of “<b>Case #X: Y</b>”. $X$ is the test case number starting from 1. $Y$ is “<b>Yes</b>” if the DFA accepts the string, or “<b>No</b>” otherwise.</div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">样例</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;"><h4>样例输入</h4><div class="ui existing segment"><pre style="margin-top:0; margin-bottom:0;"><code class="lang-plain">3
2(b3(a)b)
2 3 1
0
0 1 b
1 0 b
1 1 a
b3(a)2(b)3(a)b
2 2 1
1
0 1 b
1 0 a
b3(a)2(b)3(a)b
2 4 1
0
0 1 b
0 1 a
1 0 a
1 0 b</code></pre></div><h4>样例输出</h4><div class="ui existing segment"><pre style="margin-top:0; margin-bottom:0;"><code class="lang-plain">Case #1: Yes
Case #2: No
Case #3: Yes</div></code></pre></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">数据范围与提示</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;"> <a href="/search.php?field=problem&key=2015ACM%2FICPC%D1%C7%D6%DE%C7%F8%BA%CF%B7%CA%D5%BE-%D6%D8%CF%D6%C8%FC%A3%A8%B8%D0%D0%BB%D6%D0%BF%C6%B4%F3%A3%A9&source=1&searchmode=source"> 2015ACM/ICPC亚洲区合肥站-重现赛（感谢中科大） </a> </div></div></div></div></div></div><div class="ui vertical footer segment"><div class="ui center aligned container"><span style="color: #999;">OI-offline-problem-reader Powered by <a href="http://www.sycstudio.com">SYCstudio</a>.</span></div></div></div></body></html>