<html><head><link rel="stylesheet" type="text/css" href="../Semantic/semantic.min.css"><script src="../Semantic/jquery.min.js" type="text/javascript"></script><script src="../Semantic/semantic.min.js" type="text/javascript"></script><title>Game On the Tree</title></head><body><div class="ui main container"><div class="ui center aligned grid"><div class="row"><h1 class="ui header">HDU5369. Game On the Tree</h1></div><div class="row" style="margin-top: -15px"><span class="ui label">内存限制：8000/4000 MS (Java/Others)</span> <span class="ui label">时间限制：65536/65536 K (Java/Others)</span></div></div></br><div class="row"><div class="column"><h4 class="ui top attached block header">题目描述</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">Given a tree, a connected graph that contains $N$ vertexes and $N-1$ edges, you should control a virtual miner to get maximum values by walking from a vertex A and stopping at a vertex B.<br><br>On a tree, as we know, there is only one road between every two vertexes. Here, you are allowed to choose a vertex A (the value of A can not be 0) and a vertex B by yourself. Walking from A and stopping at B, you must collect all the values on the road. Each vertex has a value. Try to get values as large as you can. Remember that the miner you controlled, can never go back to any vertex he has passed.<br><br>However, there is a special way to calculate total values. Let’s assume that the miner has passed $M$ vertexes from A to B. During the travel, the miner has successively collected $M$ values worths $W_{i}$ $(0 \leq i &lt; M)$. Vertex A has a value worth $W_{M-1}$. The next vertex on the road has a value worth $W_{M-2}$ ...... At last, vertex B has a value worth $W_{0}$. The special rule gives you an integer $P$. The total value you collect is calculated by the formula $MAX = \sum_{i = 0}^{m-1}(W_i \times P^i)$.<br><br>It is guaranteed that $Wi$ $(0 \leq i &lt; M)$ are less than $P$. The vertex A and B you choose can be same. But the value of A can not be 0. Output $MAX$ module $(10^9 + 7)$. Note that you need to make sure $MAX$ as large as possible but $NOT$ make sure the remainder as large as possible. And then, output value of each vertex (stating from vertex A) on the road in the best case.<br></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">输入格式</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">The first line contains an integer $T (1 \leq T \leq 200)$, indicating the number of test cases.<br>For each case, The first and second line contain two integers $N$ $( 1 \leq N \leq 10^4 )$ and $P$ $( 2 \leq P \leq 10^9)$, indicating the number of vertexes and the integer $P$.<br><br>Each of the following $N-1$ lines contains two integers $a$ and $b$ $(1 \leq a, b \leq N, a \neq b)$, indicating that there is an edge connecting vertex $a$ and vertex $b$.<br><br>The following line contains $N$ integers $W_i$ $( 0 \leq W_i &lt; P, \sum W_i &gt; 0)$, the value of each vertex. It is guaranteed that at least one of $W_i$ not equal 0.<br><br>You can assume that sum of $N$ does not exceed $1.3 \times 10^6$.</div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">输出格式</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">For each case, the first line outputs &quot;Case #$T$: $MAX$&quot;(without quotes). Here, $T$ is the index of test case (starting from 1) and $MAX$ is the maximum value of treasures the miner can collect module $(10^9 + 7)$.<br><br>The second line outputs the value of each vertex from vertex A to vertex B.<br></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">样例</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;"><h4>样例输入</h4><div class="ui existing segment"><pre style="margin-top:0; margin-bottom:0;"><code class="lang-plain">2

8
2
1 2
2 3
3 4
4 5
2 6
6 7
7 8
1 0 0 0 0 0 0 0

9
1000000000
1 2
2 3
1 4
4 5
1 6
6 7
1 8
8 9
1 2 0 2 0 2 0 2 0</code></pre></div><h4>样例输出</h4><div class="ui existing segment"><pre style="margin-top:0; margin-bottom:0;"><code class="lang-plain">Case #1: 16
1 0 0 0 0
Case #2: 999999356
2 1 2 0</div></code></pre></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">数据范围与提示</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;"> <a href="/search.php?field=problem&key=2015+Multi-University+Training+Contest+7&source=1&searchmode=source"> 2015 Multi-University Training Contest 7 </a> </div></div></div></div></div></div><div class="ui vertical footer segment"><div class="ui center aligned container"><span style="color: #999;">OI-offline-problem-reader Powered by <a href="http://www.sycstudio.com">SYCstudio</a>.</span></div></div></div></body></html>