<html><head><link rel="stylesheet" type="text/css" href="../Semantic/semantic.min.css"><script src="../Semantic/jquery.min.js" type="text/javascript"></script><script src="../Semantic/semantic.min.js" type="text/javascript"></script><title>QR</title></head><body><div class="ui main container"><div class="ui center aligned grid"><div class="row"><h1 class="ui header">HDU4241. QR</h1></div><div class="row" style="margin-top: -15px"><span class="ui label">内存限制：2000/1000 MS (Java/Others)</span> <span class="ui label">时间限制：32768/32768 K (Java/Others)</span></div></div></br><div class="row"><div class="column"><h4 class="ui top attached block header">题目描述</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">QR Codes  (the smallest, which is 21 pixels by 21 pixels, is shown below) are square arrays of black or white pixels (modules) which include Position Detection Patterns (the square bull's-eye patterns), Timing Patterns (the alternating black and white lines), Alignment Patterns in larger QR Codes , Format Information (the stippled pixels), Version information in larger QR Codes and Data and Error Correction Codewords (gray 8 pixel blocks).<br><center><img style='max-width:100%;' src=./data/images/C397-1006-1.jpg></center><br>The 21-by-21 QR Code has 26 data and error correction codewords. At the lowest error correction level for this code, 19 are data codewords and 7 are error correction codewords.  Data may be encoded as numeric at 3 numbers per 10 bits, as alphanumeric at 2 characters per 11 bits, as 8 bit bytes or as Kanji at 13 bits per character. Data is encoded in groups of（mode,character count,character data bits）.The mode can change within the data stream. The mode is specified by a 4 bit code and the character count by a varying number of bits depending on the mode and QR Code size. For the 21-by-21 code, the character count bits are:<br><center><img style='max-width:100%;' src=./data/images/C397-1006-2.jpg></center><br>The entire data stream ends in the termination code which may be truncated if there is not enough room. Any partially filled codeword after the termination code is filled with 0 bits.  Any remaining codewords are set to 11101100 followed by 00010001 alternating.<br>Numeric strings are encoded 3 digits at a time. If there are remaining digits, 2 digits are encoded in 7 bits or 1 digit in 4 bits. For example:<br><br><strong>12345678 -&gt; 123 456 78 -&gt; 0001111011 0111001000 1001110 </strong><br><br>Prefix with mode (0001) and count (8 -&gt; 0000001000) is (4 + 10 + 10 + 10  +7) bits:<br><br><strong>0001 0000001000 0001111011 0111001000 1001110</strong><br><br>Alphanumeric strings encode the  haracters (&lt;SP&gt; represents the space character):<br><br><strong>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;SP&gt;$%*+-./:</strong><br><br>as numbers from 0 to 44, then two  characters are encoded in 11 bits:<br><br><strong>&lt;first char code5&gt; * 45 + &lt;second char code&gt;</strong><br><br>if the number of characters is odd, the last character is encoded in 6 bits. For example:<br><br><strong>AC-42 -&gt; (10,12,41,4,2) -&gt; 10*45+12=462, 41*45+4=1849, 2-&gt;00111001110 11100111001 000010</strong><br><br>Prefix with mode and count is (4 + 9 + 11 + 11+ 6) bits:<br><br><strong>0010 000000101 00111001110 11100111001 000010</strong><br><br>The 8 bit binary and Kanji modes will be straightforward for the purposes of this problem.  Kanji codes will just be opaque 13 bit codes; you need not decode the characters they represent, just the hexadecimal values.  For example:<br><br><strong>8 bit 0x45 0x92 0xa3 -&gt; 01000101  10010010  10100011</strong><br><br>Prefix with mode and count is (4 + 8 + 8 + 8 + 8) bits:<br><br><strong>0100 00000011 01000101  10010010  10100011<br>Kanji 0x1ABC 07x0345 -&gt; 1101010111100  0001101000101</strong><br><br>Prefix with mode and count is (4 + 8 + 13 + 13) bits:<br><br><strong>1000 00000010 1101010111100 0001101000101</strong><br><br>To illustrate forming the 19 codeword content of a QR Code, combine the first 3 sequences above (for numeric, alphanumeric and bytes). Concatenate the bits, split into 8bit code words add the termination codeword, any fill bits and fill bytes (41 + 41 + 36 data bits + 4 bit termination code  = 122 -&gt; 6 fill bits are needed to get 16 bytes, and to fill out the 19 bytes, 3 fill bytes are needed):<br><br><strong>0001 0000001000 0001111011 0111001000 1001110<br>0010 000000101 00111001110 11100111001 000010<br>0100 00000011 01000101 10010010 10100011<br>0000 000000 11101100 00010001 11101100</strong><br><br>split into 8 bit codewords:<br><br><strong>00010000 00100000 01111011 01110010 00100111 00010000 00010100 11100111 <br>01110011 10010000 10010000 00001101 00010110 01001010 10001100 00000000<br>11101100 00010001 11101100 -&gt; HEX 10207B72271014E77390900D164A8C0EC11EC</strong><br><br>Write a program to read 19 codewords and print the  orresponding data.</div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">输入格式</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">The first line of input contains a single integer P, (1 &lt;= P &lt;= 1000), which is the number of data sets that follow. Each data set is a single line of input consisting of the data set number, N, followed by a single space and 38 hexadecimal digits giving the 19 bytes of QR Code data. The valid hexadecimal digits are 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E and F.</div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">输出格式</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;">For each data set there is one line of output. It contains the data set number (N) followed by a single space, the number of QR decoded  characters in the result, a single space and the character string corresponding to the QR Code data. In the output string, printable ASCII characters (in the range 0x20 to 0x7e) are printed as the ASCII character EXCEPT that backslash (\) is printed as \\ and pound sign (#) is printed as \#. Non-printable 8 bit data is output as \xx, where x is a hexadecimal digit (e.g. \AE). Non-printable 8 bit data is any value that is less than the ASCII value of a space (0x20) or greater than 0x76. 13 bit Kanji values are printed as #bxxx, where b is 0 or 1 and x is a hexadecimal digit (e.g. #13AC).</div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">样例</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;"><h4>样例输入</h4><div class="ui existing segment"><pre style="margin-top:0; margin-bottom:0;"><code class="lang-plain">4 
1 10207B72271014E77390900D164A8C00EC11EC 
2 802D5E0D1400EC11EC11EC11EC11EC11EC11EC 
3 20BB1AA65F9FD7DC0ED88C973E15EF533EB0EC 
4 2010B110888D9428D937193B9CEA0D7F45DF68 </code></pre></div><h4>样例输出</h4><div class="ui existing segment"><pre style="margin-top:0; margin-bottom:0;"><code class="lang-plain">1 16 12345678AC-42E\92\A3
2 2 #1ABC#0345
3 23 HTTP://WWW.ACMGNYR.ORG/
4 36 3.1415926535897932384626433832795028</div></code></pre></div></div></div></div><div class="row"><div class="column"><h4 class="ui top attached block header">数据范围与提示</h4><div class="ui bottom attached segment font-content"><div style="position: relative; overflow: hidden;"> <a href="/search.php?field=problem&key=2011+Greater+New+York+Regional+&source=1&searchmode=source"> 2011 Greater New York Regional  </a> </div></div></div></div></div></div><div class="ui vertical footer segment"><div class="ui center aligned container"><span style="color: #999;">OI-offline-problem-reader Powered by <a href="http://www.sycstudio.com">SYCstudio</a>.</span></div></div></div></body></html>